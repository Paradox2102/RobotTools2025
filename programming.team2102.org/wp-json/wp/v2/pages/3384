{"id":3384,"date":"2024-09-07T01:02:55","date_gmt":"2024-09-07T01:02:55","guid":{"rendered":"http:\/\/programming.team2102.org\/?page_id=3384"},"modified":"2024-09-07T22:58:20","modified_gmt":"2024-09-07T22:58:20","slug":"turn-to-target","status":"publish","type":"page","link":"http:\/\/gabybot.com\/turn-to-target\/","title":{"rendered":"Turn To Target"},"content":{"rendered":"\n<p>Before we move on, let&#8217;s create a command which causes the robot to turn to face a specific target.<\/p>\n\n\n\n<p>The basic idea is that when we create the command we will specify the <strong>Apriltag <\/strong>number of the target we want to face. We can then get the position of that target by calling the <strong><a href=\"\/RobotCoreDoc\/classrobot_core_1_1apriltags_1_1_apriltag_locations.html#a6d11b4edd5c504ea67c7225b265ab9be\" target=\"_blank\" rel=\"noreferrer noopener\">ApriltagLocations.findTag<\/a><\/strong> function. This will return an <strong><a href=\"\/RobotCoreDoc\/classrobot_core_1_1apriltags_1_1_apriltag_location.html\" target=\"_blank\" rel=\"noreferrer noopener\">ApriltagLocation<\/a><\/strong> and from that and knowing the current location of the robot we can compute the angle we need to face.<\/p>\n\n\n\n<p>We should create a function to perform this calculation. Since it seems like this could be very useful, we should add the function to the <strong>DriveSubystem <\/strong>so it is available in multiple commands that we might make:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  \/*\n   * Return the angle to the specified Apriltags target\n   *\/\n  public double getTargetAngle(int target) {\n    ApriltagLocation location = ApriltagLocations.findTag(target);\n\n    if (location == null) {\n      throw new RuntimeException(String.format(\"Invalid target: %d\", target));\n    }\n\n    Pose2d pose = getPose2d();\n    double dx = location.m_xMeters - pose.getX();\n    double dy = location.m_yMeters - pose.getY();\n\n    return Math.toDegrees(Math.atan2(dy, dx));\n  }<\/code><\/pre>\n\n\n\n<p>Right now if the target number we specify does not exist, I am throwing an exception. This should not happen unless we have made a mistake so I throw the exception to bring it to our attention. Note, however, if this code was for an <strong>FRC <\/strong>competition robot we should do something other than throw an exception because having your program crash during a match is <strong>very <\/strong>undesirable.<\/p>\n\n\n\n<p>Now, once we have the desired angle, we need to command the robot to turn to that angle. The basic idea is to measure the difference between the robot&#8217;s current position and the desired position and set the turn rate to be proportional to that distance.<\/p>\n\n\n\n<p>To actually make the robot turn, we will use the <strong>drive <\/strong>function that we created in the <strong>DriveSubsystem<\/strong>. In the command&#8217;s <strong>execute<\/strong> we would do something like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void execute() {\n    Logger.log(\"AutoAimCommand\", -1, \"execute()\");\n\n    ...\n\n    m_subsystem.drive(0, 0, turnRate, true, ((TimedRobot) RobotCoreBase.getInstance()).getPeriod());\n  }<\/code><\/pre>\n\n\n\n<p>where we will calculated the <strong>turnRate <\/strong>(in radians\/sec) in the manner described above. We could do the calculation in the <strong>execute<\/strong> function but it is likely to be useful elsewhere so add it to the <strong>DriveSubsystem<\/strong>:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  \/*\n   * Compute the rotation rate needed to perform a turn to target maneuver\n   *\/\n  public double computeAutoAim(double targetAngleInDegrees) {\n    Pose2d pos = getPose2d();\n\n    double da = Gyro.normalizeAngle(pos.getRotation().getDegrees() - targetAngleInDegrees);\n\n    if (Math.abs(da) &gt; k_turnDeadZone) {\n      return -k_turnP * da;\n    }\n\n    return 0; \/\/ On target\n  }<\/code><\/pre>\n\n\n\n<p>Where we have created a <strong>k_turnDeadZone<\/strong> within which we stop turning. Outside the <strong>dead zone<\/strong> we compute a <strong>turn rate<\/strong> which is proportional to the amount of deviation of the <strong>current heading<\/strong> and the <strong>target heading<\/strong> where <strong>k_turnP<\/strong> is the proportional term.<\/p>\n\n\n\n<p>Our <strong>execute <\/strong>function would now look like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void execute() {\n    Logger.log(\"AutoAimCommand\", -1, \"execute()\");\n\n    double targetAngle = m_subsystem.getTargetAngle(m_targetNo);\n    double turnRate = m_subsystem.computeAutoAim(targetAngle);\n\n    m_subsystem.drive(0, 0, turnRate, true, ((TimedRobot) RobotCoreBase.getInstance()).getPeriod());\n  }<\/code><\/pre>\n\n\n\n<p>Now tie this command to a button (use <strong><a rel=\"noreferrer noopener\" href=\"\/RobotCoreDoc\/classedu_1_1wpi_1_1first_1_1wpilibj2_1_1command_1_1button_1_1_trigger.html#a75ecb23e60952eb27c8f5488745c5d66\" target=\"_blank\">whileTrue<\/a><\/strong>) and adjust the <strong>k_turnP <\/strong>like you would any normal <strong>PID P<\/strong> term, making it as large as possible without making the robot unstable.<\/p>\n\n\n\n<p>Now it would be useful to have this command automatically end when it is within the <strong>dead zone<\/strong> for the turn. In the <strong>execute<\/strong> function we know that <strong>computeAutoAim <\/strong>will return zero when in the <strong>dead zone<\/strong>, so if it is zero we can set a flag so that we can return <strong>true <\/strong>from the <strong>isFinished<\/strong>. However you will probably find that the turn may overshoot a little the first time it reaches the dead zone so you should probably only stop when it has been in the dead zone for a period of time.<\/p>\n\n\n\n<p><a href=\"http:\/\/programming.team2102.org\/path-following-3\/\" data-type=\"page\" data-id=\"3114\">Next: Path Following<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Before we move on, let&#8217;s create a command which causes the robot to turn to face a specific target. The basic idea is that when we create the command we will specify the Apriltag number of the target we want to face. We can then get the position of that target by calling the ApriltagLocations.findTag&hellip;&nbsp;<a href=\"http:\/\/gabybot.com\/turn-to-target\/\" class=\"\" rel=\"bookmark\">Read More &raquo;<span class=\"screen-reader-text\">Turn To Target<\/span><\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"neve_meta_sidebar":"","neve_meta_container":"","neve_meta_enable_content_width":"","neve_meta_content_width":0,"neve_meta_title_alignment":"","neve_meta_author_avatar":"","neve_post_elements_order":"","neve_meta_disable_header":"","neve_meta_disable_footer":"","neve_meta_disable_title":""},"_links":{"self":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/3384"}],"collection":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/comments?post=3384"}],"version-history":[{"count":12,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/3384\/revisions"}],"predecessor-version":[{"id":3405,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/3384\/revisions\/3405"}],"wp:attachment":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/media?parent=3384"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}