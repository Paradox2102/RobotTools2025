{"id":2768,"date":"2024-08-15T04:07:28","date_gmt":"2024-08-15T04:07:28","guid":{"rendered":"http:\/\/gabybot.com\/?page_id=2768"},"modified":"2025-02-07T01:02:44","modified_gmt":"2025-02-07T01:02:44","slug":"rotation-motor-tuning","status":"publish","type":"page","link":"http:\/\/gabybot.com\/rotation-motor-tuning\/","title":{"rendered":"Steering Motor Tuning"},"content":{"rendered":"\n<p>In this chapter we will configure and tune the four motors which orient the wheels. In the past we have used PID to control the speed of the motors but for the <strong>Steering <\/strong>motor we will be controlling the wheel&#8217;s position.<\/p>\n\n\n\n<h4>Motor measurements<\/h4>\n\n\n\n<p>The first thing we need to do is to run a test to measure some of the parameters of the motor. In particular we want to know what the minimum power that is needed to get the wheels to rotate. To do this you need to create a command that will ramp up the power for each of the wheels starting at zero and increasing to about 0.7 or so. If you don&#8217;t remember how to create a new command you can review that procedure from the <strong>Minibot <\/strong>tutorial <a href=\"\/commands\/\">here<\/a>.<\/p>\n\n\n\n<p>To create this command, you will need to add a function to your <strong>SwerveModule <\/strong>class that allows you to set the power for the Steering motor. Remember when you do this to be sure to set the motor mode to be sure it is in power mode:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public void setSteeringPower(double power) {\n        m_steeringMotor.setControlMode(SmartMotorMode.Power);\n        m_steeringMotor.set(power);\n    }<\/code><\/pre>\n\n\n\n<p>You will need to log the positions for each of the Steering motors so you should also add a function to your <strong>SwerveModule <\/strong>to get the current position. Note that this position will be in arbitrary units and not degrees. We will need to convert them to degrees later, but for now the arbitrary units will suffice:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public double getSteeringPosition() {\n        return m_steeringEncoder.getPosition();\n    }<\/code><\/pre>\n\n\n\n<p>Now the command will need access to all of the <strong>SwerveModule<\/strong> instances so you should create functions in your <strong>DriveSubsystem <\/strong>that will return those instances. For example:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public SwerveModuleGetFrontLeftModule() {\n    return m_frontLeft;\n  }<\/code><\/pre>\n\n\n\n<p>When you do this, you need to log the position of the wheels to the console in a CSV format so you can plot it in Libre Calc. Note that when you do this, the wheels need to be under load. That is they should be in contact with the surface. <\/p>\n\n\n\n<p>When you run your command you should verify that all of the wheels rotate in the counterclockwise direction when viewed from the top. If any of them rotate the wrong way you should call the <a href=\"\/RobotCoreDoc\/classrobot_core_1_1_smart_motor.html#a1880600586c2d55a8acd9d2b13d13097\">setInverted<\/a> function for that motor.<\/p>\n\n\n\n<p>When I do this for my robot I get something like:<\/p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-full is-resized\"><img loading=\"lazy\" src=\"\/wp-content\/uploads\/2024\/08\/SteeringRamp.jpg\" alt=\"\" class=\"wp-image-2796\" width=\"486\" height=\"283\" srcset=\"http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/SteeringRamp.jpg 751w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/SteeringRamp-300x175.jpg 300w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/SteeringRamp-150x87.jpg 150w\" sizes=\"(max-width: 486px) 100vw, 486px\" \/><\/figure><\/div>\n\n\n\n<p>The first thing you need to check is that the position values increase over time. If any of the encoders decrease, you need to call the <a href=\"\/RobotCoreDoc\/classrobot_core_1_1_encoder.html#ab0c5ccc191aea51f930b201bad153964\">setInverted<\/a> function for those encoders.<\/p>\n\n\n\n<p>What you are looking for here is the power at which each of the wheels starts rotating. You can try and read this from the graph or you can look at the actual data. In my case I defined the following constants for each of the motors.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  private static final double k_frontLeftMinSteeringPower = 0.33;\n  private static final double k_backLeftMinSteeringPower = 0.33;\n  private static final double k_backRightMinSteeringPower = 0.30;\n  private static final double k_frontRightMinsteeringPower = 0.30;<\/code><\/pre>\n\n\n\n<p>You then need to set the minimum power for each of the four <strong>Steering <\/strong>motors. To do this, create a function in the <strong>SwerveModule <\/strong>that allow you to set the value for that module:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public void setSteeringMinPower(double power) {\n        m_steeringMotor.setMinPower(power);\n    }<\/code><\/pre>\n\n\n\n<p>and then set that from within your DriveSubsystem:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    m_frontLeft.setSteeringMinPower(k_frontLeftMinSteeringPower);\n    m_backLeft.setSteeringMinPower(k_backLeftMinSteeringPower);\n    m_backRight.setSteeringMinPower(k_backRightMinSteeringPower);\n    m_frontRight.setSteeringMinPower(k_frontRightMinsteeringPower);<\/code><\/pre>\n\n\n\n<h4>Setting the zero point<\/h4>\n\n\n\n<p>Next we need to set the zero point for all of the wheels. Align all of the wheels parallel to the right side of the robot with the gear side of the wheel facing right as shown below:<\/p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-full is-resized\"><img loading=\"lazy\" src=\"\/wp-content\/uploads\/2024\/08\/AlignWheelsAnotated.jpg\" alt=\"\" class=\"wp-image-2807\" width=\"464\" height=\"348\" srcset=\"http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/AlignWheelsAnotated.jpg 1024w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/AlignWheelsAnotated-300x225.jpg 300w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/AlignWheelsAnotated-150x113.jpg 150w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/AlignWheelsAnotated-768x576.jpg 768w\" sizes=\"(max-width: 464px) 100vw, 464px\" \/><\/figure><\/div>\n\n\n\n<p>Now you need to have it print out the current Steering wheel positions for each of the wheels. You could create a command to do this, or you could simple print the values in the periodic function of the <strong>DriveSubsystem<\/strong>. Either way, here are the zero values I found for this robot.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  private static final int k_frontLeftSteeringZero = 2565;\n  private static final int k_backLeftSteeringZero = 3738;\n  private static final int k_backRightSteeringZero = 2567;\n  private static final int k_frontRightSteeringZero = 1452;<\/code><\/pre>\n\n\n\n<p>Then create a <strong>setSteeringZero <\/strong>function in your <strong>SwerveModule <\/strong>class and call it four times in your <strong>DriveSubsystem<\/strong> to set the zero position for all of the wheels.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public void setSteeringZero(int zero) {\n        m_steeringEncoder.setZero(zero);\n    }<\/code><\/pre>\n\n\n\n<h4>Converting from Encoder units to degrees<\/h4>\n\n\n\n<p>Now create a function in your <strong>SwerveModule<\/strong> that will return the wheel&#8217;s position in degrees instead of the arbitrary units of the encoder. The <strong>Encoder <\/strong>function <strong><a href=\"\/RobotCoreDoc\/classrobot_core_1_1_encoder.html#af497d8838539c6fb8409f3afe5cbf162\">getRange<\/a> <\/strong>will return the encoder value that represents 360 degrees so we can use it to convert the encoder value to degrees as in this new <strong>SwerveModule <\/strong>function:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public double getSteeringPositionInDegrees() {\n        return Gyro.normalizeAngle(getSteeringPosition() * k_degreesPerTick);\n    }<\/code><\/pre>\n\n\n\n<p>Where we have defined k_degreesPerTick as:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>        k_degreesPerTick = 360.0 \/ m_steeringEncoder.getRange();<\/code><\/pre>\n\n\n\n<p>Note that we are using the utility function <a href=\"\/RobotCoreDoc\/classrobot_core_1_1_gyro.html#afa91c63f234c1558a2b53c8f2887d3de\">normalizeAngle<\/a> provided by the <a href=\"\/RobotCoreDoc\/classrobot_core_1_1_gyro.html\">Gyro<\/a> class to force the resulting angle to be in the range of -180 to +180 degrees.<\/p>\n\n\n\n<h4>Tuning the PID<\/h4>\n\n\n\n<p>We are now ready to tune the <strong>PID <\/strong>parameters to get the wheel to turn to any desired angle. Since this is <strong>Position PID <\/strong>tuning instead of <strong>Speed<\/strong>, we will only be using the <strong>P <\/strong>and <strong>D <\/strong>terms.<\/p>\n\n\n\n<p>The first thing you need to do is to create functions in your <strong>SwerveModule <\/strong>that will let you set the <strong>P <\/strong>and <strong>D <\/strong>terms:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public void setSteeringPTerm(double p) {\n        m_steeringMotor.setPTerm(p);\n    }\n\n    public void setSteeringDTerm(double d) {\n        m_steeringMotor.setDTerm(d);\n    }<\/code><\/pre>\n\n\n\n<p>We also need a function that will set the position:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public void setSteeringPosition(double angleInDegrees) {\n        m_steeringMotor.setControlMode(SmartMotorMode.Position);\n        m_steeringMotor.set(angleInDegrees \/ k_degreesPerTick);     \/\/ Convert to encoder units\n    }<\/code><\/pre>\n\n\n\n<p>Note that when setting the position, we need to convert the angle from degrees to encoder units.<\/p>\n\n\n\n<p>You can try and tune all four motors at once, but I recommend that you work on one at a time. You should create a new command which sets the angle to a specific value and then create four instances of that command (tied to buttons) which will set the position to 0, 90, 180 and 270 degrees.<\/p>\n\n\n\n<p>First start by setting the dead zone for all of the swerve modules. It is unlikely that you will need a different dead zone for each of the four modules so you can just set this in your <strong>SwerveModule <\/strong>constructor:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>        m_steeringMotor.setDeadZone(k_deadZone \/ k_degreesPerTick);<\/code><\/pre>\n\n\n\n<p>A good initial choice for <strong>k_deadZone <\/strong>would be 2 degrees. Note also that for the call to <a href=\"\/RobotCoreDoc\/classrobot_core_1_1_smart_motor.html#ae51456cdf67c72aa079d9de507e108ca\">setDeadZone<\/a> we need to convert degrees into encoder units.<\/p>\n\n\n\n<p>Now start by setting the P term. A good starting value might be:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  private static final double k_frontLeftSteeringP = 1.0 \/ 360;\n  private static final double k_backLeftSteeringP = 1.0 \/ 360;\n  private static final double k_backRightSteeringP = 1.0 \/ 360;\n  private static final double k_frontRightSteeringP = 1.0 \/ 360;;<\/code><\/pre>\n\n\n\n<p>Note that we are defining a separate constant for each of the modules. This will allow us to use a different value for each.<\/p>\n\n\n\n<p>Now run your program and test all 4 positions, 0, 90, 180 and 270. The goal is to have the largest <strong>P <\/strong>term that does not cause the wheel to oscillate. Once you find the right number it is time to add a <strong>D <\/strong>term to see if you can damp the oscillation. A good starting value for <strong>D <\/strong>might be:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  private static final double k_frontLeftSteeringD = 0.005;\n  private static final double k_backLeftSteeringD = 0.005;\n  private static final double k_backRightSteeringD = 0.005;\n  private static final double k_frontRightSteeringD = 0.005;<\/code><\/pre>\n\n\n\n<p>You will find that when you add a <strong>D <\/strong>term, it will allow you to increase your <strong>P <\/strong>term without oscillating. The goal is to find the right combination of <strong>P <\/strong>and <strong>D <\/strong>terms that gets the wheel to the correct angle quickest without oscillation.<\/p>\n\n\n\n<p>Repeat this process for all four wheels.<\/p>\n\n\n\n<p><a href=\"\/drive-motor-tuning\/\" data-type=\"page\">Next: Drive Motor Tuning<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>In this chapter we will configure and tune the four motors which orient the wheels. In the past we have used PID to control the speed of the motors but for the Steering motor we will be controlling the wheel&#8217;s position. Motor measurements The first thing we need to do is to run a test&hellip;&nbsp;<a href=\"http:\/\/gabybot.com\/rotation-motor-tuning\/\" class=\"\" rel=\"bookmark\">Read More &raquo;<span class=\"screen-reader-text\">Steering Motor Tuning<\/span><\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"neve_meta_sidebar":"","neve_meta_container":"","neve_meta_enable_content_width":"","neve_meta_content_width":0,"neve_meta_title_alignment":"","neve_meta_author_avatar":"","neve_post_elements_order":"","neve_meta_disable_header":"","neve_meta_disable_footer":"","neve_meta_disable_title":""},"_links":{"self":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/2768"}],"collection":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/comments?post=2768"}],"version-history":[{"count":43,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/2768\/revisions"}],"predecessor-version":[{"id":4124,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/2768\/revisions\/4124"}],"wp:attachment":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/media?parent=2768"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}