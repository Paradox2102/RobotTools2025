{"id":231,"date":"2021-04-06T20:34:52","date_gmt":"2021-04-06T20:34:52","guid":{"rendered":"http:\/\/gabybot.com\/?page_id=231"},"modified":"2024-09-20T00:38:43","modified_gmt":"2024-09-20T00:38:43","slug":"combining-commands","status":"publish","type":"page","link":"http:\/\/gabybot.com\/combining-commands\/","title":{"rendered":"Combining Commands"},"content":{"rendered":"\n<p>Now that we have commands to drive and turn let\u2019s see how we can combine them to create more complex commands. Let\u2019s&nbsp;create a new command&nbsp;that will drive the robot around a certain path. &nbsp;The first step is to create a new command called&nbsp;<strong>DriveCourseCommand<\/strong>. This type of command has a different structure so this time instead of copying the&nbsp;<strong>ExampleCommand<\/strong>&nbsp;we are going to make this new class inherit from&nbsp;<strong><a rel=\"noreferrer noopener\" href=\"\/RobotCoreDoc\/classedu_1_1wpi_1_1first_1_1wpilibj2_1_1command_1_1_sequential_command_group.html\" target=\"_blank\">SequentialCommandGroup&nbsp;<\/a><\/strong>instead of&nbsp;<strong><a href=\"\/RobotCoreDoc\/classedu_1_1wpi_1_1first_1_1wpilibj2_1_1command_1_1_command.html\" target=\"_blank\" rel=\"noreferrer noopener\">Command<\/a>.<\/strong><\/p>\n\n\n\n<p>To create the new class, right click on the&nbsp;<strong>commands<\/strong>&nbsp;folder, choose&nbsp;<strong>New File,<\/strong>&nbsp;and enter the name&nbsp;<strong>DriveCourseCommand.java<\/strong>. Then replace the text in that file with:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\nimport frc.robot.subsystems.DriveSubsystem;\nimport robotCore.Logger;\n\npublic class DriveCourseCommand extends SequentialCommandGroup {\n  \/**\n   * Creates a new NewCommand.\n   *\/\n  private final DriveSubsystem m_subsystem;\n\n  public DriveCourseCommand(DriveSubsystem subsystem) {\n    Logger.log(\"DriveCourseCommand\", 3, \"DriveCourseCommand()\");\n\n    m_subsystem = subsystem;\n  }\n}<\/code><\/pre>\n\n\n\n<p>Key differences in what we&#8217;ve been doing is that 1) we inherit from\u00a0<strong><a rel=\"noreferrer noopener\" href=\"\/RobotCoreDoc\/classedu_1_1wpi_1_1first_1_1wpilibj2_1_1command_1_1_sequential_command_group.html\" target=\"_blank\">SequentialCommandGroup<\/a><\/strong> and 2) we\u00a0do not have the usual command functions (e.g.\u00a0<strong>initialize, execute<\/strong>, etc.). This is because this command will be composed of a set of commands (a <em>composite command<\/em>).<\/p>\n\n\n\n<p>To start, let&#8217;s say we want to drive forward 20 inches and then turn right by 90 degrees, we would add the following lines to the constructor:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public DriveCourseCommand(DriveSubsystem subsystem) {\n    Logger.log(\"DriveCourseCommand\", 3, \"DriveCourseCommand()\");\n\n    m_subsystem = subsystem;\n\n    double turn90 = 90;\n    double speed = 0.3;\n    double wait = 0.5;\n\n    \n    addCommands(  new DriveForDistanceCommand(m_subsystem, speed, 20),\n                  new WaitCommand(wait),\n                  new TurnCommand(m_subsystem, speed, turn90));\n  }<\/code><\/pre>\n\n\n\n<p>Notice how I placed the built in\u00a0<a rel=\"noreferrer noopener\" href=\"\/RobotCoreDoc\/classedu_1_1wpi_1_1first_1_1wpilibj2_1_1command_1_1_wait_command.html\" target=\"_blank\"><strong>WaitCommand<\/strong>\u00a0<\/a>between the\u00a0<strong>DriveForDistanceCommand<\/strong>\u00a0and\u00a0<strong>TurnCommand<\/strong>. The\u00a0<a rel=\"noreferrer noopener\" href=\"\/RobotCoreDoc\/classedu_1_1wpi_1_1first_1_1wpilibj2_1_1command_1_1_wait_command.html\" target=\"_blank\"><strong>WaitCommand<\/strong>\u00a0<\/a>does nothing but wait for a specified time. Adding a small wait between the commands will increase the accuracy of the turns. Transitioning directly from driving to turning can cause errors like wheel slippage which will throw off our turn calculations. I am also using variables\u00a0<strong>turn90,<\/strong>\u00a0<strong>speed<\/strong>, and\u00a0<strong>wait<\/strong>\u00a0rather than specifying the numbers directly in the respective constructors. I am doing this since we will be adding multiple commands that use these numbers and defining them all in one place will make it easier for us to adjust the numbers if needed.<\/p>\n\n\n\n<p>Now modify the&nbsp;<strong>RobotContainer<\/strong>&nbsp;class&nbsp;so that we run this new command when we press our test button&nbsp;<strong>6<\/strong>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\n\/* the project.                                                               *\/\n\/*----------------------------------------------------------------------------*\/\n\npackage frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.button.CommandJoystick;\nimport frc.robot.commands.DriveForTimeCommand;\nimport frc.robot.commands.TestMotorSpeedCommand;\nimport frc.robot.commands.TurnCommand;\nimport frc.robot.commands.ArcadeDriveCommand;\nimport frc.robot.commands.CalibrateSpeedCommand;\nimport frc.robot.commands.DriveCourseCommand;\nimport frc.robot.commands.DriveForDistanceCommand;\nimport frc.robot.subsystems.DriveSubsystem;\nimport frc.robot.subsystems.ExampleSubsystem;\n\n\/**\n * This class is where the bulk of the robot should be declared. Since\n * Command-based is a \"declarative\" paradigm, very little robot logic should\n * actually be handled in the {@link Robot} periodic methods (other than the\n * scheduler calls). Instead, the structure of the robot (including subsystems,\n * commands, and button mappings) should be declared here.\n *\/\npublic class RobotContainer {\n  \/\/ The robot's subsystems and commands are defined here...\n  @SuppressWarnings(\"unused\")\n  private final ExampleSubsystem m_exampleSubsystem = new ExampleSubsystem();\n  private final DriveSubsystem m_driveSubsystem = new DriveSubsystem();\n  private final CommandJoystick m_joystick = new CommandJoystick(0);\n\n\n  private final ArcadeDriveCommand m_autoCommand = null; \/\/ new ExampleCommand(m_exampleSubsystem);\n\n  \/**\n   * The container for the robot. Contains subsystems, OI devices, and commands.\n   *\/\n  public RobotContainer() {\n    m_driveSubsystem.setDefaultCommand(new ArcadeDriveCommand(m_driveSubsystem, m_joystick));\n\n    \/\/ Configure the button bindings\n    configureButtonBindings();\n  }\n\n  \/**\n   * Use this method to define your button-&gt;command mappings. Buttons can be\n   * created by instantiating a {@link GenericHID} or one of its subclasses\n   * ({@link edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then\n   * passing it to a {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.\n   *\/\n  private void configureButtonBindings() {\n    m_joystick.button(1).onTrue(new DriveForTimeCommand(m_driveSubsystem, 0.50, 3.0));\n    m_joystick.button(2).onTrue(new DriveForDistanceCommand(m_driveSubsystem, 0.75, 30));\n    m_joystick.button(3).onTrue(new TestMotorSpeedCommand(m_driveSubsystem));\n    m_joystick.button(4).whileTrue(new CalibrateSpeedCommand(m_driveSubsystem));\n    m_joystick.button(5).onTrue(new TurnCommand(m_driveSubsystem, 0.3, -180));\n    m_joystick.button(6).onTrue(new DriveCourseCommand(m_driveSubsystem));\n  }\n\n  \/**\n   * Use this to pass the autonomous command to the main {@link Robot} class.\n   *\n   * @return the command to run in autonomous\n   *\/\n  public Command getAutonomousCommand() {\n    \/\/ An ExampleCommand will run in autonomous\n    return m_autoCommand;\n  }\n}\n<\/code><\/pre>\n\n\n\n<p>Now deploy and run your program and verify that it drives forward 20 inches, turns right and then stops. Adjust the <strong>turn90<\/strong> variable so that the turn is correct.<\/p>\n\n\n\n<p>Now let\u2019s change your program so that the robot will drive in a rectangular pattern 20&nbsp;inches by 10 inches. In principle this should bring your robot back to the starting position. After you have completed and tested your code, compare it to my solution below.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>package frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.SequentialCommandGroup;\nimport edu.wpi.first.wpilibj2.command.WaitCommand;\nimport frc.robot.subsystems.DriveSubsystem;\nimport robotCore.Logger;\n\npublic class DriveCourseCommand extends SequentialCommandGroup {\n  \/**\n   * Creates a new NewCommand.\n   *\/\n  private final DriveSubsystem m_subsystem;\n\n  public DriveCourseCommand(DriveSubsystem subsystem) {\n    Logger.log(\"DriveCourseCommand\", 3, \"DriveCourseCommand()\");\n\n    m_subsystem = subsystem;\n\n    double turn90 = 85;\n    double speed = 0.3;\n    double wait = 0.5;\n    \n    addCommands(  new DriveForDistanceCommand(m_subsystem, speed, 20),\n                  new WaitCommand(wait),\n                  new TurnCommand(m_subsystem, speed, turn90),\n                  new WaitCommand(wait),\n                  new DriveForDistanceCommand(m_subsystem, speed, 10),\n                  new WaitCommand(wait),\n                  new TurnCommand(m_subsystem, speed, turn90),\n                  new WaitCommand(wait),\n                  new DriveForDistanceCommand(m_subsystem, speed, 20),\n                  new WaitCommand(wait),\n                  new TurnCommand(m_subsystem, speed, turn90),\n                  new WaitCommand(wait),\n                  new DriveForDistanceCommand(m_subsystem, speed, 10),\n                  new WaitCommand(wait),\n                  new TurnCommand(m_subsystem, speed, turn90));\n  }\n}<\/code><\/pre>\n\n\n\n<p>Note that in my case I needed set the&nbsp;<strong>turn90<\/strong>&nbsp;to&nbsp;<strong>85<\/strong>&nbsp;degrees instead of&nbsp;<strong>90<\/strong>&nbsp;in order to get the robot to drive the correct path.&nbsp;You will probably find that it was very hard to set the speed and turn parameters correctly to bring the robot back to the exact starting position. In fact, you probably saw that running the same program twice in a row actually produced a slightly different outcome. This is because there are a number of things that go on which introduce slight errors (such as wheel slippage), and these errors accumulate over time and are different every time. You might find that if you slow the robot down, you can get more reproducible results, but you can never reach the point where it is always spot on.<\/p>\n\n\n\n<p>The important take-away from this:  This kind of \u2018dead reckoning\u2019 navigation is fraught with problems. The only way to overcome these problems is to use sensors (e.g. gyro, distance sensor, camera, etc.) on the robot that give you a way to determine it\u2019s absolute position and orientation by observing and using the environment around it. This is how the competition robots determine their position on the field.<\/p>\n\n\n\n<p><a href=\"\/using-sensors\/\" data-type=\"page\">Next: Using Sensors<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Now that we have commands to drive and turn let\u2019s see how we can combine them to create more complex commands. Let\u2019s&nbsp;create a new command&nbsp;that will drive the robot around a certain path. &nbsp;The first step is to create a new command called&nbsp;DriveCourseCommand. This type of command has a different structure so this time instead&hellip;&nbsp;<a href=\"http:\/\/gabybot.com\/combining-commands\/\" class=\"\" rel=\"bookmark\">Read More &raquo;<span class=\"screen-reader-text\">Combining Commands<\/span><\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"open","template":"","meta":{"neve_meta_sidebar":"","neve_meta_container":"","neve_meta_enable_content_width":"","neve_meta_content_width":0,"neve_meta_title_alignment":"","neve_meta_author_avatar":"","neve_post_elements_order":"","neve_meta_disable_header":"","neve_meta_disable_footer":"","neve_meta_disable_title":""},"_links":{"self":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/231"}],"collection":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/comments?post=231"}],"version-history":[{"count":20,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/231\/revisions"}],"predecessor-version":[{"id":3566,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/231\/revisions\/3566"}],"wp:attachment":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/media?parent=231"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}