{"id":144,"date":"2021-04-06T16:43:02","date_gmt":"2021-04-06T16:43:02","guid":{"rendered":"http:\/\/gabybot.com\/?page_id=144"},"modified":"2024-09-05T02:17:01","modified_gmt":"2024-09-05T02:17:01","slug":"arcade-drive","status":"publish","type":"page","link":"http:\/\/gabybot.com\/arcade-drive\/","title":{"rendered":"Arcade Drive"},"content":{"rendered":"\n<p>Now that we know how to create commands, let\u2019s do something a little more useful.&nbsp;In this chapter we are going to create a&nbsp;<strong>command<\/strong>&nbsp;which will allow us to control the drive motors using a joystick.<\/p>\n\n\n\n<p>The first step is to create the new class called&nbsp;<strong>ArcadeDriveCommand<\/strong>&nbsp;under the commands folder. Like we did with the DriveSubsystem, copy the&nbsp;<strong>ExampleCommand<\/strong>&nbsp;(make sure the copy is in the commands folder). Then change the name of the copy to&nbsp;<strong>ArcadeDriveCommand.java<\/strong>&nbsp;and in that file search and replace all instances of&nbsp;<strong>ExampleCommand<\/strong>&nbsp;with&nbsp;<strong>ArcadeDriveCommand<\/strong>. Also, since this command will be using the&nbsp;<strong>DriveSubsystem<\/strong>, replace all instances of&nbsp;<strong>ExampleSubsystem<\/strong>&nbsp;with&nbsp;<strong>DriveSubsystem<\/strong>. After you have done that you ArcadeDriveCommand.java file should look like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\n\/* the project.                                                               *\/\n\/*----------------------------------------------------------------------------*\/\n\npackage frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.DriveSubsystem;\nimport robotCore.Logger;\n\n\/**\n * An example command that uses an example subsystem.\n *\/\npublic class ArcadeDriveCommand extends Command {\n  private final DriveSubsystem m_subsystem;\n\n  \/**\n   * Creates a new ArcadeDriveCommand.\n   *\n   * @param subsystem The subsystem used by this command.\n   *\/\n  public ArcadeDriveCommand(DriveSubsystem subsystem) {\n    Logger.log(\"ArcadeDriveCommand\", 3, \"ArcadeDriveCommand()\");\n\n    m_subsystem = subsystem;\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\n    addRequirements(m_subsystem);\n  }\n\n  \/\/ Called when the command is initially scheduled.\n  @Override\n  public void initialize() {\n    Logger.log(\"ArcadeDriveCommand\", 2, \"initialize()\");\n  }\n\n  \/\/ Called every time the scheduler runs while the command is scheduled.\n  @Override\n  public void execute() {\n    Logger.log(\"ArcadeDriveCommand\", -1, \"execute()\");\n  }\n\n  \/\/ Called once the command ends or is interrupted.\n  @Override\n  public void end(boolean interrupted) {\n    Logger.log(\"ArcadeDriveCommand\", 2, String.format(\"end(%b)\", interrupted));\n  }\n\n  \/\/ Returns true when the command should end.\n  @Override\n  public boolean isFinished() {\n    Logger.log(\"ArcadeDriveCommand\", -1, \"isFinished()\");\n    return false;\n  }\n}\n<\/code><\/pre>\n\n\n\n<p>Now since we are going to control the robot with the joystick, we are going to need access to the&nbsp;<strong>CommandJoystick<\/strong>&nbsp;class. We have already created an instance in the&nbsp;<strong>RobotContainer<\/strong>&nbsp;and we do not want to create a second instance here so we will pass in the&nbsp;<strong>CommandJoystick<\/strong>&nbsp;instance via the constructor:<\/p>\n\n\n\n<figure class=\"wp-block-image size-full\"><img loading=\"lazy\" width=\"774\" height=\"238\" src=\"\/wp-content\/uploads\/2024\/09\/image.png\" alt=\"\" class=\"wp-image-3119\" srcset=\"http:\/\/gabybot.com\/wp-content\/uploads\/2024\/09\/image.png 774w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/09\/image-300x92.png 300w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/09\/image-150x46.png 150w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/09\/image-768x236.png 768w\" sizes=\"(max-width: 774px) 100vw, 774px\" \/><\/figure>\n\n\n\n<p>Just like when we added a <strong>CommandJoystick<\/strong> reference in <strong>RobotContainer<\/strong>, add the <em>import<\/em> line for it using the &#8220;hover&#8221; trick.<\/p>\n\n\n\n<p><\/p>\n\n\n\n<p>Also, as we are doing with the&nbsp;<strong>DriveSubsystem<\/strong>&nbsp;parameter we have created a member variable&nbsp;<strong>m_joystick<\/strong>&nbsp;and initialized it in the constructor with the joystick argument so that we will have access to the&nbsp;<strong>CommandJoystick<\/strong>&nbsp;class for the life of this object.<\/p>\n\n\n\n<p>Your code should look like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>import edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.button.CommandJoystick;\nimport frc.robot.subsystems.DriveSubsystem;\nimport robotCore.Logger;\n\n\/**\n * An example command that uses an example subsystem.\n *\/\npublic class ArcadeDriveCommand extends Command {\n  private final DriveSubsystem m_subsystem;\n  private final CommandJoystick m_joystick;\n\n  \/**\n   * Creates a new ArcadeDriveCommand.\n   *\n   * @param subsystem The subsystem used by this command.\n   *\/\n  public ArcadeDriveCommand(DriveSubsystem subsystem, CommandJoystick joystick) {\n    Logger.log(\"ArcadeDriveCommand\", 3, \"ArcadeDriveCommand()\");\n\n    m_subsystem = subsystem;\n    m_joystick = joystick;\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\n    addRequirements(m_subsystem);\n  }<\/code><\/pre>\n\n\n\n<p><\/p>\n\n\n\n<p>Now in the&nbsp;<strong>execute()<\/strong>&nbsp;function we need to read the joystick and set the power on the motors. Let\u2019s start by just reading the&nbsp;<strong>Y&nbsp;<\/strong>value from the joystick, and make the robot drive forward and backwards using this value. The function to get the&nbsp;<strong>Y&nbsp;<\/strong>position of the joystick is&nbsp;<strong><a rel=\"noreferrer noopener\" href=\"\/RobotCoreDoc\/classrobot_core_1_1_joystick.html#a7f51b5ddd567b9f9934f2617d8d98501\" data-type=\"URL\" data-id=\"\/RobotCoreDoc\/classrobot_core_1_1_joystick.html#a7f51b5ddd567b9f9934f2617d8d98501\" target=\"_blank\">getY()<\/a><\/strong>&nbsp;and we note that it returns a number from&nbsp;<strong>-1.0<\/strong>&nbsp;to&nbsp;<strong>+1.0<\/strong>. Since the motors take their power setting in the same range, we can simply pass this on to the&nbsp;<strong>setPower(\u2026)<\/strong>&nbsp;function of our&nbsp;<strong>DriveSubsystem<\/strong>&nbsp;class:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void execute() {\n    Logger.log(\"ArcadeDriveCommand\", -1, \"execute()\");\n\n    double y = m_joystick.getY();\n\n    m_subsystem.setPower(y, y);\n  }<\/code><\/pre>\n\n\n\n<p>Your<strong> ArcadeDriveCommand.java<\/strong> file should now look like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\n\/* the project.                                                               *\/\n\/*----------------------------------------------------------------------------*\/\n\npackage frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.button.CommandJoystick;\nimport frc.robot.subsystems.DriveSubsystem;\nimport robotCore.Logger;\n\n\/**\n * An example command that uses an example subsystem.\n *\/\npublic class ArcadeDriveCommand extends Command {\n  private final DriveSubsystem m_subsystem;\n  private final CommandJoystick m_joystick;\n\n  \/**\n   * Creates a new ArcadeDriveCommand.\n   *\n   * @param subsystem The subsystem used by this command.\n   *\/\n  public ArcadeDriveCommand(DriveSubsystem subsystem, CommandJoystick joystick) {\n    Logger.log(\"ArcadeDriveCommand\", 3, \"ArcadeDriveCommand()\");\n\n    m_subsystem = subsystem;\n    m_joystick = joystick;\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\n    addRequirements(m_subsystem);\n  }\n\n  \/\/ Called when the command is initially scheduled.\n  @Override\n  public void initialize() {\n    Logger.log(\"ArcadeDriveCommand\", 2, \"initialize()\");\n  }\n\n  \/\/ Called every time the scheduler runs while the command is scheduled.\n  @Override\n  public void execute() {\n    Logger.log(\"ArcadeDriveCommand\", -1, \"execute()\");\n\n    double y = m_joystick.getY();\n\n    m_subsystem.setPower(y, y);\n  }\n\n  \/\/ Called once the command ends or is interrupted.\n  @Override\n  public void end(boolean interrupted) {\n    Logger.log(\"ArcadeDriveCommand\", 2, String.format(\"end(%b)\", interrupted));\n  }\n\n  \/\/ Returns true when the command should end.\n  @Override\n  public boolean isFinished() {\n    Logger.log(\"ArcadeDriveCommand\", -1, \"isFinished()\");\n    return false;\n  }\n}\n<\/code><\/pre>\n\n\n\n<p>To have the robot respond to joystick &#8220;stick&#8221; input, we don\u2019t want to connect this command to a button like we did with the&nbsp;<strong>DriveForTimeCommand<\/strong>. We want this command to always run &#8211; to always look for input from &#8220;stick&#8221; &#8211;  whenever no other command that requires the&nbsp;<strong>DriveSubsystem<\/strong>&nbsp;is running. To do this we add a&nbsp;<strong>setDefaultCommand(\u2026)<\/strong>&nbsp;call&nbsp;to the constructor of our&nbsp;<strong>RobotContainer<\/strong>&nbsp;class:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public RobotContainer() {\n    m_driveSubsystem.setDefaultCommand(new ArcadeDriveCommand(m_driveSubsystem, m_joystick));\n    \n    \/\/ Configure the button bindings\n    configureButtonBindings();\n  }<\/code><\/pre>\n\n\n\n<p>Here we are creating an instance of our&nbsp;<strong>ArcadeDriveCommand<\/strong>&nbsp;class and setting it as the default command for the&nbsp;<strong>DriveSubsystem<\/strong>. With this set, the&nbsp;<strong>ArcadeDriveCommand<\/strong>&nbsp;will run whenever no other command that requires the&nbsp;<strong>DriveSubsystem<\/strong>&nbsp;is running. For example, if we were to now press the B1 button the&nbsp;<strong>ArcadeDriveCommand<\/strong>&nbsp;would be interrupted and the&nbsp;<strong>DriveForTimeCommand<\/strong>&nbsp;would execute. Once the&nbsp;<strong>DriveForTimeCommand<\/strong>&nbsp;ends, the&nbsp;<strong>ArcadeDriveCommand<\/strong>&nbsp;would be restarted and the robot would once again be under joystick control.<\/p>\n\n\n\n<p>Your RobotContainer.java file should now look like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\n\/* the project.                                                               *\/\n\/*----------------------------------------------------------------------------*\/\n\npackage frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.button.CommandJoystick;\nimport frc.robot.commands.DriveForTimeCommand;\nimport frc.robot.commands.ArcadeDriveCommand;\nimport frc.robot.subsystems.DriveSubsystem;\nimport frc.robot.subsystems.ExampleSubsystem;\n\n\/**\n * This class is where the bulk of the robot should be declared. Since\n * Command-based is a \"declarative\" paradigm, very little robot logic should\n * actually be handled in the {@link Robot} periodic methods (other than the\n * scheduler calls). Instead, the structure of the robot (including subsystems,\n * commands, and button mappings) should be declared here.\n *\/\npublic class RobotContainer {\n  \/\/ The robot's subsystems and commands are defined here...\n  @SuppressWarnings(\"unused\")\n  private final ExampleSubsystem m_exampleSubsystem = new ExampleSubsystem();\n  private final DriveSubsystem m_driveSubsystem = new DriveSubsystem();\n  private final CommandJoystick m_joystick = new CommandJoystick(0);\n\n\n  private final ArcadeDriveCommand m_autoCommand = null; \/\/ new ExampleCommand(m_exampleSubsystem);\n\n  \/**\n   * The container for the robot. Contains subsystems, OI devices, and commands.\n   *\/\n  public RobotContainer() {\n    m_driveSubsystem.setDefaultCommand(new ArcadeDriveCommand(m_driveSubsystem, m_joystick));\n\n    \/\/ Configure the button bindings\n    configureButtonBindings();\n  }\n\n  \/**\n   * Use this method to define your button-&gt;command mappings. Buttons can be\n   * created by instantiating a {@link GenericHID} or one of its subclasses\n   * ({@link edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then\n   * passing it to a {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.\n   *\/\n  private void configureButtonBindings() {\n    m_joystick.button(1).onTrue(new DriveForTimeCommand(m_driveSubsystem, 0.50, 3.0));\n  }\n\n  \/**\n   * Use this to pass the autonomous command to the main {@link Robot} class.\n   *\n   * @return the command to run in autonomous\n   *\/\n  public Command getAutonomousCommand() {\n    \/\/ An ExampleCommand will run in autonomous\n    return m_autoCommand;\n  }\n}\n<\/code><\/pre>\n\n\n\n<p>Now run your program and you should be able to use the joystick to move the robot forward and backwards.<\/p>\n\n\n\n<p>Of course, we are going to want to be able to turn our robot. How are we going to do that? To make the robot turn right, we want to run the left motor forward and the right motor backwards. To turn left we need to do the opposite. If we are going to use the&nbsp;<strong>X<\/strong>&nbsp;value from the joystick, we might accomplish this by changing the&nbsp;<strong>execute()<\/strong>&nbsp;function of our&nbsp;<strong>ArcadeDriveCommand<\/strong>&nbsp;class as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void execute() {\n    Logger.log(\"ArcadeDriveCommand\", -1, \"execute()\");\n\n    double y = m_joystick.getY();\n    double x = m_joystick.getX();\n\n    m_subsystem.setPower(x, -x);\n  }<\/code><\/pre>\n\n\n\n<p>Now this will enable the robot to turn, but it will no longer drive forward and backward. See if you can figure out how to change the&nbsp;<strong>execute()<\/strong>&nbsp;function to accomplish both driving forward and backward and turning. When you have your solution, compare it to the one below:<\/p>\n\n\n\n<p class=\"has-text-color\" style=\"color:#f40000\"><strong>Don&#8217;t scroll down until you have tried to find your own solution!<\/strong><\/p>\n\n\n\n<p><strong>.<\/strong><\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public void execute() {\n    Logger.log(\"ArcadeDriveCommand\", -1, \"execute()\");\n\n    double y = m_joystick.getY();\n    double x = m_joystick.getX();\n\n    m_subsystem.setPower(y + x, y - x);\n  }<\/code><\/pre>\n\n\n\n<p>You might find that controlling the robot, especially at low speeds is a bit tricky. There is a simple way that we can improve it. Right now if we were to graph the power we apply to the motors vs the&nbsp;<strong>X<\/strong>&nbsp;or&nbsp;<strong>Y<\/strong>&nbsp;of the joystick, we would just see a straight line. What we would like to do is curve the relationship so that we have more control over the lower speeds. We can do this by cubing the&nbsp;<strong>X&nbsp;<\/strong>and&nbsp;<strong>Y<\/strong>&nbsp;values. Compare the linear (red) and cubic (blue) curves:<\/p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-large\"><img loading=\"lazy\" width=\"549\" height=\"543\" src=\"\/wp-content\/uploads\/2021\/04\/RobotJavaJoystickGraph.jpg\" alt=\"\" class=\"wp-image-155\" srcset=\"http:\/\/gabybot.com\/wp-content\/uploads\/2021\/04\/RobotJavaJoystickGraph.jpg 549w, http:\/\/gabybot.com\/wp-content\/uploads\/2021\/04\/RobotJavaJoystickGraph-300x297.jpg 300w\" sizes=\"(max-width: 549px) 100vw, 549px\" \/><\/figure><\/div>\n\n\n\n<p>Notice that in both cases, we can still get full power out of the robot by pushing the joystick full over in one direction or another (this is because 1.0 * 1.0 * 1.0 is still equal to 1.0). However for joystick positions less than 1.0, we see that the power output increases much more slowly than the linear case, allowing for better control at the lower speeds. We can implement this change in our&nbsp;<strong>execute()<\/strong>&nbsp;function as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void execute() {\n    Logger.log(\"ArcadeDriveCommand\", -1, \"execute()\");\n\n    double y = m_joystick.getY();\n    double x = m_joystick.getX();\n\n    x = x * x * x;\n    y = y * y * y;\n\n    m_subsystem.setPower(y + x, y - x);\n  }<\/code><\/pre>\n\n\n\n<p>Try it out and see if you don\u2019t have better control over the robot.<\/p>\n\n\n\n<p>Note that we could also just square the inputs which would result in a less drastic flattening of the curve. However if we wanted to use the square, we would need to take care to make sure that the sign was correct when&nbsp;<strong>X<\/strong>&nbsp;or&nbsp;<strong>Y<\/strong>&nbsp;becomes negative (remember that&nbsp;<strong>-1.0 * -1.0<\/strong>&nbsp;is equal to&nbsp;<strong>+1.0<\/strong>). As an exercise, why don\u2019t you see if you can come up with a solution that squares the inputs but still preserves the sign. You can then compare your solution to the one below:<\/p>\n\n\n\n<p><strong>.<\/strong><\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void execute() \n  {\n    Logger.log(\"ArcadeDriveCommand\", -1, \"execute()\");\n    \n    double\ty\t= m_joystick.getY();\n    double\tx\t= m_joystick.getX();\n    \n    if (x &lt; 0)\n    {\n      x = -x * x;\n    }\n    else\n    {\n      x = x * x;\n    }\n    \n    if (y &lt; 0)\n    {\n      y = -y * y;\n    }\n    else\n    {\n      y = y * y;\n    }\n    \n    m_subsystem.setPower(y + x, y - x);\n  }<\/code><\/pre>\n\n\n\n<p>As a final note, there is another way this may be accomplished by using the <strong>Math.abs<\/strong> function which returns the absolute value of a number.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void execute() \n  {\n    Logger.log(\"ArcadeDriveCommand\", -1, \"execute()\");\n    \n    double\ty\t= m_joystick.getY();\n    double\tx\t= m_joystick.getX();\n    \n    x = Math.abs(x) * x;\n    y = Math.abs(y) * y;\n\n    m_subsystem.setPower(y + x, y - x);\n  }<\/code><\/pre>\n\n\n\n<p>By taking the absolute value and multiplying it by itself, we square the value but retain the sign. While this involves less typing it may or may be less intuitive.<\/p>\n\n\n\n<p>Finally you can also do this using the <strong><a rel=\"noreferrer noopener\" href=\"https:\/\/docs.oracle.com\/javase\/8\/docs\/api\/java\/lang\/Math.html#signum-double-\" target=\"_blank\">Math.signum<\/a><\/strong> function which returns <strong>+1<\/strong> if the number is positive and <strong>-1<\/strong> if the number is negative.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void execute() \n  {\n    Logger.log(\"ArcadeDriveCommand\", -1, \"execute()\");\n    \n    double\ty\t= m_joystick.getY();\n    double\tx\t= m_joystick.getX();\n    \n    x = x * x * Math.signum(x);\n    y = y * y * Math.signum(y);\n\n    m_subsystem.setPower(y + x, y - x);\n  }<\/code><\/pre>\n\n\n\n<p>These show that there are many correct ways to solve a problem given the tools Java provides&#8230;and in general!<\/p>\n\n\n\n<p><a href=\"\/wheel-encoders\/\" data-type=\"page\">Next: Wheel Encoders<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Now that we know how to create commands, let\u2019s do something a little more useful.&nbsp;In this chapter we are going to create a&nbsp;command&nbsp;which will allow us to control the drive motors using a joystick. The first step is to create the new class called&nbsp;ArcadeDriveCommand&nbsp;under the commands folder. Like we did with the DriveSubsystem, copy the&nbsp;ExampleCommand&nbsp;(make&hellip;&nbsp;<a href=\"http:\/\/gabybot.com\/arcade-drive\/\" class=\"\" rel=\"bookmark\">Read More &raquo;<span class=\"screen-reader-text\">Arcade Drive<\/span><\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"open","template":"","meta":{"neve_meta_sidebar":"","neve_meta_container":"","neve_meta_enable_content_width":"","neve_meta_content_width":0,"neve_meta_title_alignment":"","neve_meta_author_avatar":"","neve_post_elements_order":"","neve_meta_disable_header":"","neve_meta_disable_footer":"","neve_meta_disable_title":""},"_links":{"self":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/144"}],"collection":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/comments?post=144"}],"version-history":[{"count":45,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/144\/revisions"}],"predecessor-version":[{"id":3298,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/144\/revisions\/3298"}],"wp:attachment":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/media?parent=144"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}