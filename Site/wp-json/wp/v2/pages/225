{"id":225,"date":"2021-04-06T20:27:33","date_gmt":"2021-04-06T20:27:33","guid":{"rendered":"http:\/\/gabybot.com\/?page_id=225"},"modified":"2025-08-13T01:49:42","modified_gmt":"2025-08-13T01:49:42","slug":"turn-command","status":"publish","type":"page","link":"http:\/\/gabybot.com\/turn-command\/","title":{"rendered":"Turn Command"},"content":{"rendered":"\n<p>Next we are going to create a command called&nbsp;<strong>TurnCommand<\/strong>&nbsp;which will allow us to turn the robot in place by a specified angle. You should know enough now to create the framework for this command. We will want to specify the speed&nbsp;to be used in the turn as well as the angle so create the constructor for your class so that it takes two&nbsp;<strong>double<\/strong>&nbsp;parameters, the first to specify the&nbsp;<strong>speed&nbsp;<\/strong>and the second to specify the&nbsp;<strong>angle<\/strong>. After you have created the new command, compare you code to the code below.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\n\/* the project.                                                               *\/\n\/*----------------------------------------------------------------------------*\/\n\npackage frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.DriveSubsystem;\nimport robotCore.Logger;\n\n\/**\n * A command to turn the robot by a specific angle.\n *\/\npublic class TurnCommand extends Command {\n  private final DriveSubsystem m_subsystem;\n  private double m_speed;\n  private double m_angle;\n\n  \/**\n   * Creates a new TurnCommand.\n   *\n   * @param subsystem The subsystem used by this command.\n   *\/\n  public TurnCommand(DriveSubsystem subsystem, double speed, double angle) {\n    Logger.log(\"TurnCommand\", 3, \"TurnCommand()\");\n\n    m_subsystem = subsystem;\n    m_speed = speed;\n    m_angle = angle;\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\n    addRequirements(m_subsystem);\n  }\n\n  \/\/ Called when the command is initially scheduled.\n  @Override\n  public void initialize() {\n    Logger.log(\"TurnCommand\", 2, \"initialize()\");\n  }\n\n  \/\/ Called every time the scheduler runs while the command is scheduled.\n  @Override\n  public void execute() {\n    Logger.log(\"TurnCommand\", -1, \"execute()\");\n  }\n\n  \/\/ Called once the command ends or is interrupted.\n  @Override\n  public void end(boolean interrupted) {\n    Logger.log(\"TurnCommand\", 2, String.format(\"end(%b)\", interrupted));\n  }\n\n  \/\/ Returns true when the command should end.\n  @Override\n  public boolean isFinished() {\n    Logger.log(\"TurnCommand\", -1, \"isFinished()\");\n    return false;\n  }\n}<\/code><\/pre>\n\n\n\n<p>Did you create some member variables (e.g.&nbsp;<strong>m_speed<\/strong>&nbsp;and&nbsp;<strong>m_angle<\/strong>) to store the speed and angle that are passed in on the constructor?<\/p>\n\n\n\n<p>Now we are going to use the encoders to measure the turn. Once again, we will want to use copies of the encoders like we did in our&nbsp;<strong>DriveForDistanceCommand<\/strong>. Add code to declare and initialize the left and right encoder:<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>public class TurnCommand extends Command {\n  private final DriveSubsystem m_subsystem;\n  private double m_speed;\n  private double m_angle;\n  private Encoder m_leftEncoder;\n  private Encoder m_rightEncoder;\n\n  \/**\n   * Creates a new TurnCommand.\n   *\n   * @param subsystem The subsystem used by this command.\n   *\/\n  public TurnCommand(DriveSubsystem subsystem, double speed, double angle) {\n    Logger.log(\"TurnCommand\", 3, \"TurnCommand()\");\n\n    m_subsystem = subsystem;\n    m_speed = speed;\n    m_angle = angle;\n    m_leftEncoder = m_subsystem.getLeftEncoder();\n    m_rightEncoder = m_subsystem.getRightEncoder();\n\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\n    addRequirements(m_subsystem);\n  }<\/code><\/pre>\n\n\n\n<p>Now in the&nbsp;<strong>initialize()<\/strong>&nbsp;function we also want reset the encoders and turn the motors on. <\/p>\n\n\n\n<p>To make the robot turn, we need to set the speed to the left and right motors opposite, and we need to set the signs so that it turns in the correct direction. Let\u2019s say that a positive&nbsp;<strong>angle<\/strong>&nbsp;should&nbsp;make the robot turn to the right (clockwise) and a negative&nbsp;<strong>angle<\/strong>&nbsp;should&nbsp;make the robot turn to the left (anticlockwise). See if you can add code to your&nbsp;<strong>initialize()<\/strong>&nbsp;function to accomplish this and then check your result with the one below.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void initialize() {\n    Logger.log(\"TurnCommand\", 2, \"initialize()\");\n\n    m_leftEncoder.reset();\n    m_rightEncoder.reset();\n\n    if (m_angle &lt; 0)\n    {\n        m_subsystem.setSpeed(-m_speed, m_speed);    \/\/ Turn left\n    }\n    else\n    {\n        m_subsystem.setSpeed(m_speed, -m_speed);    \/\/ Turn right\n    }\n  }<\/code><\/pre>\n\n\n\n<p>Now we need to add some code to the&nbsp;<strong>isFinished()<\/strong>&nbsp;function to return&nbsp;<strong>true<\/strong>&nbsp;when the robot has turned by the requested angle. Add the following line to the&nbsp;<strong>isFinished()<\/strong>&nbsp;function:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    \tint\tdelta\t= m_leftEncoder.get() - m_rightEncoder.get();<\/code><\/pre>\n\n\n\n<p>Note that&nbsp;<strong>delta<\/strong>&nbsp;will be&nbsp;<strong>positive<\/strong>&nbsp;if the robot is turning right (i.e. the left wheel is moving forward and the right wheel is moving backward), and&nbsp;<strong>negative<\/strong>&nbsp;if the robot is turning left. The magnitude of&nbsp;<strong>delta<\/strong>&nbsp;will also be a measure of how far the robot is turned. So lets return&nbsp;<strong>true<\/strong>&nbsp;when the magnitude of&nbsp;<strong>delta<\/strong>&nbsp;exceeds the magnitude of the&nbsp;<strong>angle<\/strong>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public boolean isFinished() {\n    Logger.log(\"TurnCommand\", -1, \"isFinished()\");\n\n    int delta = m_leftEncoder.get() - m_rightEncoder.get();\n\n    return (Math.abs(delta) &gt;= Math.abs(m_angle));\n  }<\/code><\/pre>\n\n\n\n<p>Note that we are using the absolute value of both&nbsp;<strong>delta<\/strong>&nbsp;and&nbsp;<strong>m_angle<\/strong>&nbsp;in the comparison since they can both be negative.<\/p>\n\n\n\n<p>Remember to turn the motors back off in the&nbsp;<strong>end()<\/strong>&nbsp;function. Your&nbsp;<strong>TurnCommand.java<\/strong>&nbsp;file should now look like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\n\/* the project.                                                               *\/\n\/*----------------------------------------------------------------------------*\/\n\npackage frc.robot.commands;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport frc.robot.subsystems.DriveSubsystem;\nimport robotCore.Encoder;\nimport robotCore.Logger;\n\n\/**\n * A command to turn the robot by a specific angle.\n *\/\npublic class TurnCommand extends Command {\n  private final DriveSubsystem m_subsystem;\n  private double m_speed;\n  private double m_angle;\n  private Encoder m_leftEncoder;\n  private Encoder m_rightEncoder;\n\n  \/**\n   * Creates a new TurnCommand.\n   *\n   * @param subsystem The subsystem used by this command.\n   *\/\n  public TurnCommand(DriveSubsystem subsystem, double speed, double angle) {\n    Logger.log(\"TurnCommand\", 3, \"TurnCommand()\");\n\n    m_subsystem = subsystem;\n    m_speed = speed;\n    m_angle = angle;\n    m_leftEncoder = m_subsystem.getLeftEncoder();\n    m_rightEncoder = m_subsystem.getRightEncoder();\n\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\n    addRequirements(m_subsystem);\n  }\n\n  \/\/ Called when the command is initially scheduled.\n  @Override\n  public void initialize() {\n    Logger.log(\"TurnCommand\", 2, \"initialize()\");\n\n    m_leftEncoder.reset();\n    m_rightEncoder.reset();\n\n    if (m_angle &lt; 0) {\n      m_subsystem.setSpeed(-m_speed, m_speed); \/\/ Turn left\n    } else {\n      m_subsystem.setSpeed(m_speed, -m_speed); \/\/ Turn right\n    }\n  }\n\n  \/\/ Called every time the scheduler runs while the command is scheduled.\n  @Override\n  public void execute() {\n    Logger.log(\"TurnCommand\", -1, \"execute()\");\n  }\n\n  \/\/ Called once the command ends or is interrupted.\n  @Override\n  public void end(boolean interrupted) {\n    Logger.log(\"TurnCommand\", 2, String.format(\"end(%b)\", interrupted));\n    \n    m_subsystem.stop();\n  }\n\n  \/\/ Returns true when the command should end.\n  @Override\n  public boolean isFinished() {\n    Logger.log(\"TurnCommand\", -1, \"isFinished()\");\n\n    int delta = m_leftEncoder.get() - m_rightEncoder.get();\n\n    return (Math.abs(delta) &gt;= Math.abs(m_angle));\n  }\n}<\/code><\/pre>\n\n\n\n<p>For now&nbsp;we will&nbsp;pass in an&nbsp;<strong>angle<\/strong>&nbsp;in the encoder units and see how far the robot turns (later we will find the conversion factor so we can enter our angle in degrees). Configure the&nbsp;<strong>RobotContainer<\/strong> class so that this command will be executed with&nbsp;<strong>0.3<\/strong>&nbsp;speed for and&nbsp;<strong>angle<\/strong>&nbsp;of&nbsp;<strong>1500<\/strong> when we press button&nbsp;<strong>5<\/strong>&nbsp;on the joystick. When you have made that change, compare it to the code below.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\n\/* the project.                                                               *\/\n\/*----------------------------------------------------------------------------*\/\n\npackage frc.robot;\n\nimport edu.wpi.first.wpilibj2.command.Command;\nimport edu.wpi.first.wpilibj2.command.button.CommandJoystick;\nimport frc.robot.commands.DriveForTimeCommand;\nimport frc.robot.commands.TestMotorSpeedCommand;\nimport frc.robot.commands.TurnCommand;\nimport frc.robot.commands.ArcadeDriveCommand;\nimport frc.robot.commands.CalibrateSpeedCommand;\nimport frc.robot.commands.DriveForDistanceCommand;\nimport frc.robot.subsystems.DriveSubsystem;\nimport frc.robot.subsystems.ExampleSubsystem;\n\n\/**\n * This class is where the bulk of the robot should be declared. Since\n * Command-based is a \"declarative\" paradigm, very little robot logic should\n * actually be handled in the {@link Robot} periodic methods (other than the\n * scheduler calls). Instead, the structure of the robot (including subsystems,\n * commands, and button mappings) should be declared here.\n *\/\npublic class RobotContainer {\n  \/\/ The robot's subsystems and commands are defined here...\n  @SuppressWarnings(\"unused\")\n  private final ExampleSubsystem m_exampleSubsystem = new ExampleSubsystem();\n  private final DriveSubsystem m_driveSubsystem = new DriveSubsystem();\n  private final CommandJoystick m_joystick = new CommandJoystick(0);\n\n\n  private final ArcadeDriveCommand m_autoCommand = null; \/\/ new ExampleCommand(m_exampleSubsystem);\n\n  \/**\n   * The container for the robot. Contains subsystems, OI devices, and commands.\n   *\/\n  public RobotContainer() {\n    m_driveSubsystem.setDefaultCommand(new ArcadeDriveCommand(m_driveSubsystem, m_joystick));\n\n    \/\/ Configure the button bindings\n    configureButtonBindings();\n  }\n\n  \/**\n   * Use this method to define your button-&gt;command mappings. Buttons can be\n   * created by instantiating a {@link GenericHID} or one of its subclasses\n   * ({@link edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then\n   * passing it to a {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.\n   *\/\n  private void configureButtonBindings() {\n    m_joystick.button(1).onTrue(new DriveForTimeCommand(m_driveSubsystem, 0.50, 3.0));\n    m_joystick.button(2).onTrue(new DriveForDistanceCommand(m_driveSubsystem, 0.75, 30));\n    m_joystick.button(3).onTrue(new TestMotorSpeedCommand(m_driveSubsystem));\n    m_joystick.button(4).whileTrue(new CalibrateSpeedCommand(m_driveSubsystem));\n    m_joystick.button(5).onTrue(new TurnCommand(m_driveSubsystem, 0.3, 1500));\n  }\n\n  \/**\n   * Use this to pass the autonomous command to the main {@link Robot} class.\n   *\n   * @return the command to run in autonomous\n   *\/\n  public Command getAutonomousCommand() {\n    \/\/ An ExampleCommand will run in autonomous\n    return m_autoCommand;\n  }\n}\n<\/code><\/pre>\n\n\n\n<p>Now deploy and run your program and see how far the robot turns. Try and find a number to replace the&nbsp;<strong>1500 <\/strong>value that will make the robot turn exactly&nbsp;<strong>360<\/strong>&nbsp;degrees.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>In my case I found that approximately&nbsp;<strong>4700<\/strong><font color=\"blue\"> <\/font>encoder units will make the robot turn&nbsp;<strong>360<\/strong>&nbsp;degrees. This means that if the input angle is in degrees, we need to multiply it by <font color=\"blue\"><mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-neve-text-color-color\"><strong>4700.0\/360<\/strong><\/mark><\/font> to get the number of encoder units that we need. <em>NOTE that the value for your robot may be different, but the math is the same!<\/em> Implementing this in the code we get:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public TurnCommand(DriveSubsystem subsystem, double speed, double angle) {\n    Logger.log(\"TurnCommand\", 3, \"TurnCommand()\");\n\n    m_subsystem = subsystem;\n    m_speed = speed;\n    m_angle = angle * k_ticksPerDegree;\n    m_leftEncoder = m_subsystem.getLeftEncoder();\n    m_rightEncoder = m_subsystem.getRightEncoder();\n\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\n    addRequirements(m_subsystem);\n  }<\/code><\/pre>\n\n\n\n<p>Where I have defined <strong>k_ticksPerDegree<\/strong> as:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>private final double k_ticksPerDegree = 4700.0 \/ 360;<\/code><\/pre>\n\n\n\n<p>Note that I have used <strong>4700.0<\/strong> rather than just <strong>4700<\/strong> because I need to force it to use floating point when evaluating the expression.<\/p>\n\n\n\n<p>Your <strong>TurnCommand.java<\/strong> should now look like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\r\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\r\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\r\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\r\n\/* the project.                                                               *\/\r\n\/*----------------------------------------------------------------------------*\/\r\n\r\npackage frc.robot.commands;\r\n\r\nimport edu.wpi.first.wpilibj2.command.Command;\r\nimport frc.robot.subsystems.DriveSubsystem;\r\nimport robotCore.Encoder;\r\nimport robotCore.Logger;\r\n\r\n\/**\r\n * A command to turn the robot by a specific angle.\r\n *\/\r\npublic class TurnCommand extends Command {\r\n  private final DriveSubsystem m_subsystem;\r\n  private double m_speed;\r\n  private double m_angle;\r\n  private Encoder m_leftEncoder;\r\n  private Encoder m_rightEncoder;\r\n  private final double k_ticksPerDegree = 4700.0 \/ 360;\r\n\r\n  \/**\r\n   * Creates a new TurnCommand.\r\n   *\r\n   * @param subsystem The subsystem used by this command.\r\n   *\/\r\n  public TurnCommand(DriveSubsystem subsystem, double speed, double angle) {\r\n    Logger.log(\"TurnCommand\", 3, \"TurnCommand()\");\r\n\r\n    m_subsystem = subsystem;\r\n    m_speed = speed;\r\n    m_angle = angle * k_ticksPerDegree;\r\n    m_leftEncoder = m_subsystem.getLeftEncoder();\r\n    m_rightEncoder = m_subsystem.getRightEncoder();\r\n\r\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\r\n    addRequirements(m_subsystem);\r\n  }\r\n\r\n  \/\/ Called when the command is initially scheduled.\r\n  @Override\r\n  public void initialize() {\r\n    Logger.log(\"TurnCommand\", 2, \"initialize()\");\r\n\r\n    m_leftEncoder.reset();\r\n    m_rightEncoder.reset();\r\n\r\n    if (m_angle &lt; 0) {\r\n      m_subsystem.setSpeed(-m_speed, m_speed); \/\/ Turn left\r\n    } else {\r\n      m_subsystem.setSpeed(m_speed, -m_speed); \/\/ Turn right\r\n    }\r\n  }\r\n\r\n  \/\/ Called every time the scheduler runs while the command is scheduled.\r\n  @Override\r\n  public void execute() {\r\n    Logger.log(\"TurnCommand\", -1, \"execute()\");\r\n  }\r\n\r\n  \/\/ Called once the command ends or is interrupted.\r\n  @Override\r\n  public void end(boolean interrupted) {\r\n    Logger.log(\"TurnCommand\", 2, String.format(\"end(%b)\", interrupted));\r\n    \r\n    m_subsystem.stop();\r\n  }\r\n\r\n  \/\/ Returns true when the command should end.\r\n  @Override\r\n  public boolean isFinished() {\r\n    Logger.log(\"TurnCommand\", -1, \"isFinished()\");\r\n\r\n    int delta = m_leftEncoder.get() - m_rightEncoder.get();\r\n\r\n    return (Math.abs(delta) >= Math.abs(m_angle));\r\n  }\r\n}<\/code><\/pre>\n\n\n\n<p>Now change the line in the&nbsp;<strong>RobotContainer<\/strong>&nbsp;to turn the robot by&nbsp;<strong>180<\/strong>&nbsp;degrees:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    m_joystick.button(5).onTrue(new TurnCommand(m_driveSubsystem, 0.3, 180));\n<\/code><\/pre>\n\n\n\n<p>Before moving on, verify that if you specify a negative&nbsp;<strong>angle<\/strong>&nbsp;the robot will turn the other way:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    m_joystick.button(5).onTrue(new TurnCommand(m_driveSubsystem, 0.3, -180));\n<\/code><\/pre>\n\n\n\n<p>You may find that the robot does not turn exactly the desired <strong>180 <\/strong>degrees. This is because the accuracy of the turns using this method is poor because of wheel slippage and other issues. If the robot had a gyroscope, we could use that for more accurate turns, but since it does not, we will need to live with the inaccuracies.<\/p>\n\n\n\n<p><a href=\"\/combining-commands\/\" data-type=\"page\">Next: Combining Commands<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Next we are going to create a command called&nbsp;TurnCommand&nbsp;which will allow us to turn the robot in place by a specified angle. You should know enough now to create the framework for this command. We will want to specify the speed&nbsp;to be used in the turn as well as the angle so create the constructor&hellip;&nbsp;<a href=\"http:\/\/gabybot.com\/turn-command\/\" class=\"\" rel=\"bookmark\">Read More &raquo;<span class=\"screen-reader-text\">Turn Command<\/span><\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"open","template":"","meta":{"neve_meta_sidebar":"","neve_meta_container":"","neve_meta_enable_content_width":"","neve_meta_content_width":0,"neve_meta_title_alignment":"","neve_meta_author_avatar":"","neve_post_elements_order":"","neve_meta_disable_header":"","neve_meta_disable_footer":"","neve_meta_disable_title":""},"_links":{"self":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/225"}],"collection":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/comments?post=225"}],"version-history":[{"count":26,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/225\/revisions"}],"predecessor-version":[{"id":4871,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/225\/revisions\/4871"}],"wp:attachment":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/media?parent=225"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}