{"id":2851,"date":"2024-08-16T21:24:23","date_gmt":"2024-08-16T21:24:23","guid":{"rendered":"http:\/\/gabybot.com\/?page_id=2851"},"modified":"2025-02-13T06:24:30","modified_gmt":"2025-02-13T06:24:30","slug":"drive-motor-tuning","status":"publish","type":"page","link":"http:\/\/gabybot.com\/drive-motor-tuning\/","title":{"rendered":"Drive Motor Tuning"},"content":{"rendered":"\n<p>We are now ready to PID tune the drive motors.<\/p>\n\n\n\n<h4>Drive motor characteristics<\/h4>\n\n\n\n<p>The first thing you need to do is determine the drive motor characteristics. The two important number that we need are the minimum power and the max speed. Do get these we will once again create a command that will drive the robot forward using a power that ramps from <strong>0<\/strong> to about <strong>1.2<\/strong>. The reason we go to <strong>1.2<\/strong> rather than the max of <strong>1<\/strong> is so that we can get a good measure of the maximum speed.<\/p>\n\n\n\n<p>Create a new command <strong>TestDriveRamp<\/strong>. In the <strong>initialize <\/strong>function, set the steering position for all the motors to zero degrees so the robot will drive mostly straight. In the <strong>execute <\/strong>function log the power and the speed for all four of the drive motors. Then increment the power and set the new value. Then in the <strong>isFinished <\/strong>function return true when the power is greater than or equal to <strong>1.2<\/strong>.<\/p>\n\n\n\n<p>When I do this, this is my result:<\/p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-full is-resized\"><img loading=\"lazy\" src=\"\/wp-content\/uploads\/2024\/08\/DriveRamp.jpg\" alt=\"\" class=\"wp-image-2861\" width=\"438\" height=\"242\" srcset=\"http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/DriveRamp.jpg 750w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/DriveRamp-300x166.jpg 300w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/DriveRamp-150x83.jpg 150w\" sizes=\"(max-width: 438px) 100vw, 438px\" \/><\/figure><\/div>\n\n\n\n<p>You need to glean two things from this graph. The first is the <strong>minimum power<\/strong> to get the motors to start. That value is the intersection of the linear portion of the graphs with the x axis. In this case you could estimate this from the graph to be about 0.3 for all of the motors. If you want a more precise answer, you can plot just the linear portions of the graphs and fit them to a line which will give you the intercept:<\/p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-full is-resized\"><img loading=\"lazy\" src=\"\/wp-content\/uploads\/2024\/08\/DriveMinPower.jpg\" alt=\"\" class=\"wp-image-2865\" width=\"451\" height=\"257\" srcset=\"http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/DriveMinPower.jpg 813w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/DriveMinPower-300x171.jpg 300w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/DriveMinPower-150x85.jpg 150w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/DriveMinPower-768x437.jpg 768w\" sizes=\"(max-width: 451px) 100vw, 451px\" \/><\/figure><\/div>\n\n\n\n<p>The second thing you need is the <strong>maximum speed<\/strong>. The max speed you set needs to be the slowest of the four motors. In my case it looks to be <strong>2500<\/strong>. Define these values as constants in your <strong>DriveSubsystem <\/strong>and set call the <strong>setMinSpeed <\/strong>functions (which you must create) for the four module&#8217;s <strong>SwerveModule <\/strong>instance:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  private static final double k_frontLeftMinDrivePower = 0.29;\n  private static final double k_backLeftMinDrivePower = 0.29;\n  private static final double k_backRightMinDrivePower = 0.30;\n  private static final double k_frontRightMinDrivePower = 0.30;\n\n  private static final double k_maxDriveSpeed = 2500;\n\n...\n\n    m_frontLeft.setDriveMinPower(k_frontLeftMinDrivePower);\n    m_backLeft.setDriveMinPower(k_backLeftMinDrivePower);\n    m_backRight.setDriveMinPower(k_backRightMinDrivePower);\n    m_frontRight.setDriveMinPower(k_frontRightMinDrivePower);<\/code><\/pre>\n\n\n\n<p>Now you are ready to tune the <strong>PID <\/strong>values. You should create a <strong>CalibrateDrive <\/strong>command. Like you do for the <strong>TestDriveRamp <\/strong>command, in it&#8217;s <strong>initialize<\/strong> function you should set the angle for all of the wheels to <strong>0<\/strong> degrees so the robot will drive straight:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    m_frontLeft.setSteeringPosition(0);\n    m_backLeft.setSteeringPosition(0);\n    m_backRight.setSteeringPosition(0);\n    m_frontRight.setSteeringPosition(0);<\/code><\/pre>\n\n\n\n<h4>IMPORTANT<\/h4>\n\n\n\n<p>Before we start, if you remember when we programmed the <strong>Minibot<\/strong>, we made a call to the <a rel=\"noreferrer noopener\" href=\"\/RobotCoreDoc\/classrobot_core_1_1_smart_motor.html#aacbea70f88c25cac67e9039e11ad07e1\" target=\"_blank\">setMaxSpeed()<\/a> function of the <strong><a href=\"\/RobotCoreDoc\/classrobot_core_1_1_p_w_m_motor.html\">PWMMotor<\/a> <\/strong>class after we determined this value. We did this so we could use the output of the joystick (which had values between <strong>-1<\/strong> and <strong>1<\/strong>) as direct input to control the motor&#8217;s speed via the <a rel=\"noreferrer noopener\" href=\"\/RobotCoreDoc\/classrobot_core_1_1_smart_motor.html#a14f9dea236ecceb69e3c5d097fba54c0\" target=\"_blank\">set()<\/a> call. For the <strong>Minibot<\/strong>, this was a very convenient way to control the robot in our <strong>ArcadeDrive <\/strong>command. <\/p>\n\n\n\n<p>However for this robot we will <strong>not <\/strong>be passing the joystick values directly to the motors. Instead we will call a complex function which will take the joystick values and compute the <strong>speed <\/strong>and <strong>angle <\/strong>for each of the swerve modules that will get the robot to drive in the correct direction. The <strong>speed <\/strong>that is returned from this function will be in <strong>meters\/second<\/strong> and we will use these units to set the <strong>speed<\/strong> for the motors. As a result we do <strong>NOT <\/strong>want to call <a rel=\"noreferrer noopener\" href=\"\/RobotCoreDoc\/classrobot_core_1_1_smart_motor.html#aacbea70f88c25cac67e9039e11ad07e1\" target=\"_blank\">setMaxSpeed()<\/a> for this robot. The <strong>setSpeed<\/strong> function that you create should <strong>always <\/strong>take the speed in the <strong>arbitrary encoder units<\/strong>. We will, of course, need to later create another function that will convert <strong>meters\/second<\/strong> into these <strong>arbitrary units<\/strong>.<\/p>\n\n\n\n<p>Now you can tune the <strong>F<\/strong>, <strong>P <\/strong>and <strong>I<\/strong> parameters (we generally don&#8217;t use the <strong>D <\/strong>parameter when tuning speed control). The method for doing this is similar to the one you used for the <strong>Minibot<\/strong>. First you set the <strong>F <\/strong>term (a good starting value would be <strong>1.0\/k_maxSpeed<\/strong>). You then add a <strong>P <\/strong>term and increase it until the speed becomes unstable. A good starting point for the <strong>P <\/strong>term would be <strong>0.0001<\/strong>.<\/p>\n\n\n\n<p>Finally you add the <strong>I <\/strong>term (along with an <strong>IZone<\/strong>) and increase that until the speed becomes unstable. A good starting point for the <strong>I <\/strong>term would be <strong>0.0001<\/strong>.<\/p>\n\n\n\n<p>When I tuned my robot the following were my results:<\/p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-full is-resized\"><img loading=\"lazy\" src=\"\/wp-content\/uploads\/2024\/08\/DriveCalibration.jpg\" alt=\"\" class=\"wp-image-2881\" width=\"534\" height=\"294\" srcset=\"http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/DriveCalibration.jpg 812w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/DriveCalibration-300x165.jpg 300w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/DriveCalibration-150x83.jpg 150w, http:\/\/gabybot.com\/wp-content\/uploads\/2024\/08\/DriveCalibration-768x423.jpg 768w\" sizes=\"(max-width: 534px) 100vw, 534px\" \/><\/figure><\/div>\n\n\n\n<p>I did my tuning at a speed of <strong>2000 <\/strong>and checked it at a speed of <strong>1000<\/strong>. My final numbers were as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  private static final double k_frontLeftDriveF = 1.05 \/ k_maxDriveSpeed;\n  private static final double k_backLeftDriveF = 1.05 \/ k_maxDriveSpeed;\n  private static final double k_backRightDriveF = 0.95 \/ k_maxDriveSpeed;\n  private static final double k_frontRightDriveF = 0.95 \/ k_maxDriveSpeed;\n\n  public static final double k_drivePTerm = 0.0010;\n  public static final double k_driveITerm = 0.0004;\n  public static final double k_driveIZone = 200;\n<\/code><\/pre>\n\n\n\n<h4>Calibrate drive encoder<\/h4>\n\n\n\n<p>Finally we need to compute the conversion factor from encoder units (<strong>ticks<\/strong>, <strong>ticks\/sec<\/strong>) to real world units (<strong>meters<\/strong>, <strong>meters\/sec<\/strong>). To do this create a command <strong>CalibrateDistance<\/strong>. Set up this command to drive the robot forward at a relative slow speed for a short distance and record the position of each of the drive wheels using the encoder&#8217;s <a href=\"\/RobotCoreDoc\/classrobot_core_1_1_encoder.html#aa419f8ba2dacaab3a312aff2eeebb872\">getPosition <\/a>function.<\/p>\n\n\n\n<p>I did this for my robot and found that <strong>1.345<\/strong> meters equals <strong>3579 <\/strong>encoder ticks. This allows me to define the following constants in the <strong>DriveSubsystem<\/strong>:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  private static final double k_maxDriveSpeed = 2500;\n  private static final double k_ticksPerMeter = 3579 \/ 1.345;\n  private static final double k_maxDriveSpeedMetersPerSecond = k_maxDriveSpeed \/ k_ticksPerMeter; \/\/ = 0.9395 m\/s<\/code><\/pre>\n\n\n\n<p>Which then allows me to create the following functions in the <strong>SwerveModule<\/strong>:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public void setDriveSpeedInMetersPerSecond(double speed) {\n        setDriveSpeed(speed * DriveSubsystem.k_ticksPerMeter);\n    }\n\n    public double getDriveSpeedInMetersPerSecond() {\n        return getDriveSpeed() \/ DriveSubsystem.k_ticksPerMeter;\n    }\n\n    public double getDrivePositionInMetersPerSecond() {\n        return getDrivePosition() \/ DriveSubsystem.k_ticksPerMeter;\n    }<\/code><\/pre>\n\n\n\n<p>Remember, as discussed above, in order for this to work correctly your <strong>setDriveSpeed <\/strong>function must take the speed in the native encoder units of <strong>ticks\/sec<\/strong> and not in the range of <strong>-1<\/strong> to <strong>1<\/strong> which would be the case if you had used the <a rel=\"noreferrer noopener\" href=\"\/RobotCoreDoc\/classrobot_core_1_1_smart_motor.html#aacbea70f88c25cac67e9039e11ad07e1\" target=\"_blank\">setMaxSpeed()<\/a> function as you did when programming the <strong>Minibot<\/strong>.<\/p>\n\n\n\n<p><a href=\"\/arcade-drive-2\/\" data-type=\"page\" data-id=\"2875\">Next: Arcade Drive<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>We are now ready to PID tune the drive motors. Drive motor characteristics The first thing you need to do is determine the drive motor characteristics. The two important number that we need are the minimum power and the max speed. Do get these we will once again create a command that will drive the&hellip;&nbsp;<a href=\"http:\/\/gabybot.com\/drive-motor-tuning\/\" class=\"\" rel=\"bookmark\">Read More &raquo;<span class=\"screen-reader-text\">Drive Motor Tuning<\/span><\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"neve_meta_sidebar":"","neve_meta_container":"","neve_meta_enable_content_width":"","neve_meta_content_width":0,"neve_meta_title_alignment":"","neve_meta_author_avatar":"","neve_post_elements_order":"","neve_meta_disable_header":"","neve_meta_disable_footer":"","neve_meta_disable_title":""},"_links":{"self":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/2851"}],"collection":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/comments?post=2851"}],"version-history":[{"count":30,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/2851\/revisions"}],"predecessor-version":[{"id":4135,"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/pages\/2851\/revisions\/4135"}],"wp:attachment":[{"href":"http:\/\/gabybot.com\/wp-json\/wp\/v2\/media?parent=2851"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}